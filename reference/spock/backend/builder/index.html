
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../../../../resources/images/logo_small.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.0">
    
    
      
        <title>Builder - spock</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.8b42a75e.min.css">
      
        
        <link rel="stylesheet" href="../../../../assets/stylesheets/palette.3f5d1f46.min.css">
        
          
          
          <meta name="theme-color" content="#546d78">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="blue-grey" data-md-color-accent="pink">
  
    
    <script>function __prefix(e){return new URL("../../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module-spockbackendbuilder" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="spock" class="md-header__button md-logo" aria-label="spock" data-md-component="logo">
      
  <img src="../../../../resources/images/logo_small.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            spock
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Builder
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/fidelity/spock/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    spock
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="spock" class="md-nav__button md-logo" aria-label="spock" data-md-component="logo">
      
  <img src="../../../../resources/images/logo_small.png" alt="logo">

    </a>
    spock
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/fidelity/spock/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    spock
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/Installation/" class="md-nav__link">
        Installation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/Motivation/" class="md-nav__link">
        Motivation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/Quick-Start/" class="md-nav__link">
        Quick Start
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/ArgParser-Replacement/" class="md-nav__link">
        argparse Replacement
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          Basic Tutorial
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Basic Tutorial" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Basic Tutorial
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/basic_tutorial/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/basic_tutorial/Define/" class="md-nav__link">
        Define
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/basic_tutorial/Building/" class="md-nav__link">
        Building
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/basic_tutorial/Configuration-Files/" class="md-nav__link">
        Configuration Files
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/basic_tutorial/Saving/" class="md-nav__link">
        Saving
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/basic_tutorial/Run/" class="md-nav__link">
        Running
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" type="checkbox" id="__nav_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_7">
          Advanced Features
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Advanced Features" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Advanced Features
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Defaults/" class="md-nav__link">
        Default Values
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Optional-Parameters/" class="md-nav__link">
        Optional Parameters
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Parameter-Groups/" class="md-nav__link">
        Parameter Groups
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Inheritance/" class="md-nav__link">
        Inheritance
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Advanced-Types/" class="md-nav__link">
        Advanced Types
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Local-Definitions/" class="md-nav__link">
        Local Defintions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Keyword-Configs/" class="md-nav__link">
        Keyword Configs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Composition/" class="md-nav__link">
        Composition
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/advanced_features/Command-Line-Overrides/" class="md-nav__link">
        Command Line Overrides
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_8" type="checkbox" id="__nav_8" >
      
      
      
      
        <label class="md-nav__link" for="__nav_8">
          Addons
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Addons" data-md-level="1">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          Addons
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/addons/S3/" class="md-nav__link">
        S3
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_8_2" type="checkbox" id="__nav_8_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_8_2">
          Hyper-Parameter Tuning
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Hyper-Parameter Tuning" data-md-level="2">
        <label class="md-nav__title" for="__nav_8_2">
          <span class="md-nav__icon md-icon"></span>
          Hyper-Parameter Tuning
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/addons/tuner/About/" class="md-nav__link">
        About
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/addons/tuner/Basics/" class="md-nav__link">
        Basics
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/addons/tuner/Ax/" class="md-nav__link">
        Ax
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/addons/tuner/Optuna/" class="md-nav__link">
        Optuna
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/addons/tuner/Saving/" class="md-nav__link">
        Saving
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../../CONTRIBUTING/" class="md-nav__link">
        Contributing
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10" type="checkbox" id="__nav_10" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_10">
          Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_10">
          <span class="md-nav__icon md-icon"></span>
          Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1" type="checkbox" id="__nav_10_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1">
          Spock
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Spock" data-md-level="2">
        <label class="md-nav__title" for="__nav_10_1">
          <span class="md-nav__icon md-icon"></span>
          Spock
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../args/" class="md-nav__link">
        Args
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../builder/" class="md-nav__link">
        Builder
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../config/" class="md-nav__link">
        Config
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../handlers/" class="md-nav__link">
        Handlers
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1_7" type="checkbox" id="__nav_10_1_7" >
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1_7">
          Addons
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Addons" data-md-level="3">
        <label class="md-nav__title" for="__nav_10_1_7">
          <span class="md-nav__icon md-icon"></span>
          Addons
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1_7_2" type="checkbox" id="__nav_10_1_7_2" >
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1_7_2">
          S3
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="S3" data-md-level="4">
        <label class="md-nav__title" for="__nav_10_1_7_2">
          <span class="md-nav__icon md-icon"></span>
          S3
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/s3/configs/" class="md-nav__link">
        Configs
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/s3/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/s3/utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1_7_3" type="checkbox" id="__nav_10_1_7_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1_7_3">
          Tune
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Tune" data-md-level="4">
        <label class="md-nav__title" for="__nav_10_1_7_3">
          <span class="md-nav__icon md-icon"></span>
          Tune
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/ax/" class="md-nav__link">
        Ax
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/builder/" class="md-nav__link">
        Builder
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/config/" class="md-nav__link">
        Config
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/interface/" class="md-nav__link">
        Interface
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/optuna/" class="md-nav__link">
        Optuna
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/payload/" class="md-nav__link">
        Payload
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../addons/tune/tuner/" class="md-nav__link">
        Tuner
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_10_1_8" type="checkbox" id="__nav_10_1_8" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_10_1_8">
          Backend
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Backend" data-md-level="3">
        <label class="md-nav__title" for="__nav_10_1_8">
          <span class="md-nav__icon md-icon"></span>
          Backend
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Builder
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Builder
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#attrbuilder" class="md-nav__link">
    AttrBuilder
  </a>
  
    <nav class="md-nav" aria-label="AttrBuilder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_override_parsers" class="md-nav__link">
    build_override_parsers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate" class="md-nav__link">
    generate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#handle_help_info" class="md-nav__link">
    handle_help_info
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basebuilder" class="md-nav__link">
    BaseBuilder
  </a>
  
    <nav class="md-nav" aria-label="BaseBuilder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_1" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#descendants" class="md-nav__link">
    Descendants
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_1" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_override_parsers_1" class="md-nav__link">
    build_override_parsers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_1" class="md-nav__link">
    generate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#handle_help_info_1" class="md-nav__link">
    handle_help_info
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../config/" class="md-nav__link">
        Config
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../handler/" class="md-nav__link">
        Handler
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../payload/" class="md-nav__link">
        Payload
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../saver/" class="md-nav__link">
        Saver
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../typed/" class="md-nav__link">
        Typed
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        Utils
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../wrappers/" class="md-nav__link">
        Wrappers
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#attrbuilder" class="md-nav__link">
    AttrBuilder
  </a>
  
    <nav class="md-nav" aria-label="AttrBuilder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_override_parsers" class="md-nav__link">
    build_override_parsers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate" class="md-nav__link">
    generate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#handle_help_info" class="md-nav__link">
    handle_help_info
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basebuilder" class="md-nav__link">
    BaseBuilder
  </a>
  
    <nav class="md-nav" aria-label="BaseBuilder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_1" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#descendants" class="md-nav__link">
    Descendants
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_1" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build_override_parsers_1" class="md-nav__link">
    build_override_parsers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generate_1" class="md-nav__link">
    generate
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#handle_help_info_1" class="md-nav__link">
    handle_help_info
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/fidelity/spock/edit/main/reference/spock/backend/builder.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="module-spockbackendbuilder">Module spock.backend.builder</h1>
<p>Handles the building/saving of the configurations from the Spock config classes</p>
<p>None</p>
<p>??? example "View Source"
        # -<em>- coding: utf-8 -</em>-</p>
<div class="highlight"><pre><span></span><code>    # Copyright FMR LLC &lt;opensource@fidelity.com&gt;

    # SPDX-License-Identifier: Apache-2.0



    &quot;&quot;&quot;Handles the building/saving of the configurations from the Spock config classes&quot;&quot;&quot;



    import re

    import sys

    from abc import ABC, abstractmethod

    from enum import EnumMeta

    from typing import List



    import attr

    from attr import NOTHING



    from spock.backend.wrappers import Spockspace

    from spock.utils import make_argument





    class BaseBuilder(ABC):  # pylint: disable=too-few-public-methods

        &quot;&quot;&quot;Base class for building the backend specific builders



        This class handles the interface to the backend with the generic ConfigArgBuilder so that different

        backends can be used to handle processing



        *Attributes*



            input_classes: list of input classes that link to a backend

            _configs: None or List of configs to read from

            _desc: description for the arg parser

            _no_cmd_line: flag to force no command line reads

            _max_indent: maximum to indent between help prints

            save_path: list of path(s) to save the configs to



        &quot;&quot;&quot;



        def __init__(self, *args, max_indent=4, module_name, **kwargs):

            self.input_classes = args

            self._module_name = module_name

            self._max_indent = max_indent

            self.save_path = None



        @staticmethod

        @abstractmethod

        def _make_group_override_parser(parser, class_obj, class_name):

            &quot;&quot;&quot;Makes a name specific override parser for a given class obj



            Takes a class object of the backend and adds a new argument group with argument names given with name

            Class.name so that individual parameters specific to a class can be overridden.



            *Args*:



                parser: argument parser

                class_obj: instance of a backend class

                class_name: used for module matching



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;



        def handle_help_info(self):

            &quot;&quot;&quot;Handles walking through classes to get help info



            For each class this function will search __doc__ and attempt to pull out help information for both the class

            itself and each attribute within the class



            *Returns*:



                None



            &quot;&quot;&quot;

            self._attrs_help(self.input_classes, self._module_name)



        def _handle_arguments(self, args, class_obj):

            &quot;&quot;&quot;Handles all argument mapping



            Creates a dictionary of named parameters that are mapped to the final type of object



            *Args*:



                args: read file arguments

                class_obj: instance of a class obj



            *Returns*:



                fields: dictionary of mapped parameters



            &quot;&quot;&quot;

            attr_name = class_obj.__name__

            class_names = [val.__name__ for val in self.input_classes]

            # Handle repeated classes

            if (

                attr_name in class_names

                and attr_name in args

                and isinstance(args[attr_name], list)

            ):

                fields = self._handle_repeated(args[attr_name], attr_name, class_names)

            # Handle non-repeated classes

            else:

                fields = {}

                for val in class_obj.__attrs_attrs__:

                    # Check if namespace is named and then check for key -- checking for local class def

                    if attr_name in args and val.name in args[attr_name]:

                        fields[val.name] = self._handle_nested_class(

                            args, args[attr_name][val.name], class_names

                        )

                    # If not named then just check for keys -- checking for global def

                    elif val.name in args:

                        fields[val.name] = self._handle_nested_class(

                            args, args[val.name], class_names

                        )

                    # Check for special keys to set

                    if (

                        &quot;special_key&quot; in val.metadata

                        and val.metadata[&quot;special_key&quot;] is not None

                    ):

                        if val.name in args:

                            self.save_path = args[val.name]

                        elif val.default is not None:

                            self.save_path = val.default

            return fields



        def _handle_repeated(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles repeated classes as lists



            *Args*:



                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                list of input_class[match)idx[0]] types filled with repeated values



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            return [self.input_classes[match_idx[0]](**val) for val in args]



        def _handle_nested_class(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles passing another class to the field dictionary



            *Args*:

                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                either the check_value or the necessary class



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            # If so then create the needed class object by unrolling the args to **kwargs and return it

            if len(match_idx) &gt; 0:

                if len(match_idx) &gt; 1:

                    raise ValueError(

                        &quot;Match error -- multiple classes with the same name definition&quot;

                    )

                else:

                    if args.get(self.input_classes[match_idx[0]].__name__) is None:

                        raise ValueError(

                            f&quot;Missing config file definition for the referenced class &quot;

                            f&quot;{self.input_classes[match_idx[0]].__name__}&quot;

                        )

                    current_arg = args.get(self.input_classes[match_idx[0]].__name__)

                    if isinstance(current_arg, list):

                        class_value = [

                            self.input_classes[match_idx[0]](**val) for val in current_arg

                        ]

                    else:

                        class_value = self.input_classes[match_idx[0]](**current_arg)

                return_value = class_value

            # else return the expected value

            else:

                return_value = check_value

            return return_value



        def generate(self, dict_args):

            &quot;&quot;&quot;Method to auto-generate the actual class instances from the generated args



            Based on the generated arguments groups and the args read in from the config file(s)

            this function instantiates the classes with the necessary field or attr values



            *Args*:



                dict_args: dictionary of arguments from the configs



            *Returns*:



                namespace containing automatically generated instances of the classes

            &quot;&quot;&quot;

            auto_dict = {}

            for attr_classes in self.input_classes:

                attr_build = self._auto_generate(dict_args, attr_classes)

                if isinstance(attr_build, list):

                    class_name = list({type(val).__name__ for val in attr_build})

                    if len(class_name) &gt; 1:

                        raise ValueError(&quot;Repeated class has more than one unique name&quot;)

                    auto_dict.update({class_name[0]: attr_build})

                else:

                    auto_dict.update({type(attr_build).__name__: attr_build})

            return Spockspace(**auto_dict)



        def _auto_generate(self, args, input_class):

            &quot;&quot;&quot;Builds an instance of an attr class



            Builds an instance with the necessary field values from the argument

            dictionary read from the config file(s)



            *Args*:



                args: dictionary of arguments read from the config file(s)

                data_class: data class to build



            *Returns*:



                An instance of data_class with correct values assigned to fields

            &quot;&quot;&quot;

            # Handle the basic data types

            fields = self._handle_arguments(args, input_class)

            if isinstance(fields, list):

                return_value = fields

            else:

                self._handle_late_defaults(args, fields, input_class)

                return_value = input_class(**fields)

            return return_value



        def _handle_late_defaults(self, args, fields, input_class):

            &quot;&quot;&quot;Handles late defaults when the type is non-standard



            If the default type is not a base python type then we need to catch those defaults here and build the correct

            values from the input classes while maintaining the optional nature. The trick is to exclude all &#39;base&#39; types

            as these defaults are covered by the attr default value



            *Args*:



                args: dictionary of arguments read from the config file(s)

                fields: current fields returned from _handle_arguments

                input_class: which input class being checked for late defaults



            *Returns*:



                fields: updated field dictionary with late defaults set



            &quot;&quot;&quot;

            names = [val.name for val in input_class.__attrs_attrs__]

            class_names = [val.__name__ for val in self.input_classes]

            field_list = list(fields.keys())

            arg_list = list(args.keys())

            # Exclude all the base types that are supported -- these can be set by attrs

            exclude_list = [

                &quot;_Nothing&quot;,

                &quot;NoneType&quot;,

                &quot;bool&quot;,

                &quot;int&quot;,

                &quot;float&quot;,

                &quot;str&quot;,

                &quot;list&quot;,

                &quot;tuple&quot;,

            ]

            for val in names:

                if val not in field_list:

                    # Gets the name of the class to default to

                    default_type_name = type(

                        getattr(input_class.__attrs_attrs__, val).default

                    ).__name__

                    if default_type_name not in exclude_list:

                        # Gets the default class object

                        default_attr = getattr(input_class.__attrs_attrs__, val).default

                        # If the default is given for a class then it&#39;s the actual class and not a type -- logic needs

                        # to deal with both

                        if type(default_attr).__name__ == &quot;type&quot;:

                            default_name = default_attr.__name__

                        else:

                            default_name = type(default_attr).__name__

                    # Skip if in the exclude list

                    else:

                        default_name = None

                    # if we need to fall back onto the default and ff it&#39;s in the arg_list then we have a

                    # definition coming in from the config file

                    if default_name is not None and default_name in arg_list:

                        # This handles lists of class type repeats -- these cannot be nested as the logic would be too

                        # confusing to map to

                        if isinstance(args.get(default_name), list):

                            default_value = [

                                self.input_classes[class_names.index(default_name)](

                                    **arg_val

                                )

                                for arg_val in args.get(default_name)

                            ]

                        # This handles basics and references to other classes -- here we need to recurse to grab any nested

                        # defs since classes are passed as strings to the config but are defined via Enums (handled #139)

                        else:

                            recurse_args = self._handle_recursive_defaults(

                                args.get(default_name), args, class_names

                            )

                            default_value = self.input_classes[

                                class_names.index(default_name)

                            ](**recurse_args)

                        fields.update({val: default_value})

            return fields



        def _handle_recursive_defaults(self, curr_arg, all_args, class_names):

            &quot;&quot;&quot;Recurses through the args from the config read to determine if it can map to a definition



            *Args*:



                curr_arg: current argument

                all_args: all argument dictionary

                class_names: list of class names



            *Returns*:



                out_dict: recursively mapped dictionary of attributes



            &quot;&quot;&quot;

            out_dict = {}

            for k, v in curr_arg.items():

                # If the value is a reference to another class we need to recurse

                if v in class_names:

                    # Recurse only if in the all_args dict (from the config file)

                    if v in all_args:

                        bubbled_dict = self._handle_recursive_defaults(

                            all_args.get(v), all_args, class_names

                        )

                        out_dict.update(

                            {k: self.input_classes[class_names.index(v)](**bubbled_dict)}

                        )

                    # Else fall back on default instantiation

                    else:

                        out_dict.update({k: self.input_classes[class_names.index(v)]()})

                else:

                    out_dict.update({k: v})

            return out_dict



        def build_override_parsers(self, parser):

            &quot;&quot;&quot;Creates parsers for command-line overrides



            Builds the basic command line parser for configs and help then iterates through each attr instance to make

            namespace specific cmd line override parsers



            *Args*:



                parser: argument parser



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;

            # Build out each class override specific parser

            for val in self.input_classes:

                parser = self._make_group_override_parser(

                    parser=parser, class_obj=val, class_name=self._module_name

                )

            return parser



        @staticmethod

        def _get_from_kwargs(args, configs):

            &quot;&quot;&quot;Get configs from the configs kwarg



            *Args*:



                args: argument namespace

                configs: config kwarg



            *Returns*:



                args: arg namespace



            &quot;&quot;&quot;

            if isinstance(configs, list):

                args.config.extend(configs)

            else:

                raise TypeError(

                    f&quot;configs kwarg must be of type list -- given {type(configs)}&quot;

                )

            return args



        @staticmethod

        def _find_attribute_idx(newline_split_docs):

            &quot;&quot;&quot;Finds the possible split between the header and Attribute annotations



            *Args*:



                newline_split_docs: new line split text



            Returns:



                idx: -1 if none or the idx of Attributes



            &quot;&quot;&quot;

            for idx, val in enumerate(newline_split_docs):

                re_check = re.search(r&quot;(?i)Attribute?s?:&quot;, val)

                if re_check is not None:

                    return idx

            return -1



        def _split_docs(self, obj):

            &quot;&quot;&quot;Possibly splits head class doc string from attribute docstrings



            Attempts to find the first contiguous line within the Google style docstring to use as the class docstring.

            Splits the docs base on the Attributes tag if present.



            *Args*:



                obj: class object to rip info from



            *Returns*:



                class_doc: class docstring if present or blank str

                attr_doc: list of attribute doc strings



            &quot;&quot;&quot;

            if obj.__doc__ is not None:

                # Split by new line

                newline_split_docs = obj.__doc__.split(&quot;\n&quot;)

                # Cleanup l/t whitespace

                newline_split_docs = [val.strip() for val in newline_split_docs]

            else:

                newline_split_docs = []

            # Find the break between the class docs and the Attribute section -- if this returns -1 then there is no

            # Attributes section

            attr_idx = self._find_attribute_idx(newline_split_docs)

            head_docs = (

                newline_split_docs[:attr_idx] if attr_idx != -1 else newline_split_docs

            )

            attr_docs = newline_split_docs[attr_idx:] if attr_idx != -1 else []

            # Grab only the first contiguous line as everything else will probably be too verbose (e.g. the

            # mid-level docstring that has detailed descriptions

            class_doc = &quot;&quot;

            for idx, val in enumerate(head_docs):

                class_doc += f&quot; {val}&quot;

                if idx + 1 != len(head_docs) and head_docs[idx + 1] == &quot;&quot;:

                    break

            # Clean up any l/t whitespace

            class_doc = class_doc.strip()

            if len(class_doc) &gt; 0:

                class_doc = f&quot;-- {class_doc}&quot;

            return class_doc, attr_docs



        @staticmethod

        def _match_attribute_docs(

            attr_name, attr_docs, attr_type_str, attr_default=NOTHING

        ):

            &quot;&quot;&quot;Matches class attributes with attribute docstrings via regex



            *Args*:



                attr_name: attribute name

                attr_docs: list of attribute docstrings

                attr_type_str: str representation of the attribute type

                attr_default: str representation of a possible default value



            *Returns*:



                dictionary of packed attribute information



            &quot;&quot;&quot;

            # Regex match each value

            a_str = None

            for a_doc in attr_docs:

                match_re = re.search(r&quot;(?i)^&quot; + attr_name + &quot;?:&quot;, a_doc)

                # Find only the first match -- if more than one than ignore

                if match_re:

                    a_str = a_doc[match_re.end() :].strip()

            return {

                attr_name: {

                    &quot;type&quot;: attr_type_str,

                    &quot;desc&quot;: a_str if a_str is not None else &quot;&quot;,

                    &quot;default&quot;: &quot;(default: &quot; + repr(attr_default) + &quot;)&quot;

                    if type(attr_default).__name__ != &quot;_Nothing&quot;

                    else &quot;&quot;,

                    &quot;len&quot;: {&quot;name&quot;: len(attr_name), &quot;type&quot;: len(attr_type_str)},

                }

            }



        def _handle_attributes_print(self, info_dict):

            &quot;&quot;&quot;Prints attribute information in an argparser style format



            *Args*:



                info_dict: packed attribute info dictionary to print



            &quot;&quot;&quot;

            # Figure out indents

            max_param_length = max([len(k) for k in info_dict.keys()])

            max_type_length = max([v[&quot;len&quot;][&quot;type&quot;] for v in info_dict.values()])

            # Print akin to the argparser

            for k, v in info_dict.items():

                print(

                    f&quot;    {k}&quot;

                    + (&quot; &quot; * (max_param_length - v[&quot;len&quot;][&quot;name&quot;] + self._max_indent))

                    + f&#39;{v[&quot;type&quot;]}&#39;

                    + (&quot; &quot; * (max_type_length - v[&quot;len&quot;][&quot;type&quot;] + self._max_indent))

                    + f&#39;{v[&quot;desc&quot;]} {v[&quot;default&quot;]}&#39;

                )

            # Blank for spacing :-/

            print(&quot;&quot;)



        def _extract_other_types(self, typed, module_name):

            &quot;&quot;&quot;Takes a high level type and recursively extracts any enum or class types



            *Args*:



                typed: highest level type

                module_name: name of module to match



            *Returns*:



                return_list: list of nums (dot notation of module_path.enum_name or module_path.class_name)



            &quot;&quot;&quot;

            return_list = []

            if hasattr(typed, &quot;__args__&quot;):

                for val in typed.__args__:

                    recurse_return = self._extract_other_types(val, module_name)

                    if isinstance(recurse_return, list):

                        return_list.extend(recurse_return)

                    else:

                        return_list.append(self._extract_other_types(val, module_name))

            elif isinstance(typed, EnumMeta) or (typed.__module__ == module_name):

                return [f&quot;{typed.__module__}.{typed.__name__}&quot;]

            return return_list



        def _attrs_help(self, input_classes, module_name):

            &quot;&quot;&quot;Handles walking through a list classes to get help info



            For each class this function will search __doc__ and attempt to pull out help information for both the class

            itself and each attribute within the class. If it finds a repeated class in a iterable object it will

            recursively call self to handle information



            *Args*:



                input_classes: list of attr classes

                module_name: name of module to match



            *Returns*:



                None



            &quot;&quot;&quot;

            # Handle the main loop

            other_list = self._handle_help_main(input_classes, module_name)

            self._handle_help_enums(other_list=other_list, module_name=module_name)



        @staticmethod

        def _get_type_string(val, nested_others):

            &quot;&quot;&quot;Gets the type of the attr val as a string



            *Args*:



                val: current attr being processed

                nested_others: list of nested others to deal with that might have module path info in the string



            *Returns*:



                type_string: type of the attr as a str



            &quot;&quot;&quot;

            # Grab the base or type info depending on what is provided

            if &quot;type&quot; in val.metadata:

                type_string = repr(val.metadata[&quot;type&quot;])

            elif &quot;base&quot; in val.metadata:

                type_string = val.metadata[&quot;base&quot;]

            elif hasattr(val.type, &quot;__name__&quot;):

                type_string = val.type.__name__

            else:

                type_string = str(val.type)

            # Regex out the typing info if present

            type_string = re.sub(r&quot;typing.&quot;, &quot;&quot;, type_string)

            # Regex out any nested_others that have module path information

            for other_val in nested_others:

                split_other = f&quot;{&#39;.&#39;.join(other_val.split(&#39;.&#39;)[:-1])}.&quot;

                type_string = re.sub(split_other, &quot;&quot;, type_string)

            # Regex the string to see if it matches any Enums in the __main__ module space

            # Construct the type with the metadata

            if &quot;optional&quot; in val.metadata:

                type_string = f&quot;Optional[{type_string}]&quot;

            return type_string



        def _handle_help_main(self, input_classes, module_name):

            &quot;&quot;&quot;Handles the print of the main class types



            *Args*:



                input_classes: current set of input classes

                module_name: module name to match



            *Returns*:



                other_list: extended list of other classes/enums to process



            &quot;&quot;&quot;

            # List to catch Enums and classes and handle post spock wrapped attr classes

            other_list = []

            covered_set = set()

            for attrs_class in input_classes:

                # Split the docs into class docs and any attribute docs

                class_doc, attr_docs = self._split_docs(attrs_class)

                print(&quot;  &quot; + attrs_class.__name__ + f&quot; {class_doc}&quot;)

                # Keep a running info_dict of all the attribute level info

                info_dict = {}

                for val in attrs_class.__attrs_attrs__:

                    # If the type is an enum we need to handle it outside of this attr loop

                    # Match the style of nested enums and return a string of module.name notation

                    if isinstance(val.type, EnumMeta):

                        other_list.append(f&quot;{val.type.__module__}.{val.type.__name__}&quot;)

                    # if there is a type (implied Iterable) -- check it for nested Enums or classes

                    nested_others = self._extract_fnc(val, module_name)

                    if len(nested_others) &gt; 0:

                        other_list.extend(nested_others)

                    # Get the type represented as a string

                    type_string = self._get_type_string(val, nested_others)

                    info_dict.update(

                        self._match_attribute_docs(

                            val.name, attr_docs, type_string, val.default

                        )

                    )

                # Add to covered so we don&#39;t print help twice in the case of some recursive nesting

                covered_set.add(f&quot;{attrs_class.__module__}.{attrs_class.__name__}&quot;)

                self._handle_attributes_print(info_dict=info_dict)

            # Convert the enum list to a set to remove dupes and then back to a list so it is iterable -- set diff to not

            # repeat

            return list(set(other_list) - covered_set)



        def _handle_help_enums(self, other_list, module_name):

            &quot;&quot;&quot;handles any extra enums from non main args



            *Args*:



                other_list: extended list of other classes/enums to process

                module_name: module name to match



            *Returns*:



                None



            &quot;&quot;&quot;

            # Iterate any Enum type classes

            for other in other_list:

                # if it&#39;s longer than 2 then it&#39;s an embedded Spock class

                if &quot;.&quot;.join(other.split(&quot;.&quot;)[:-1]) == module_name:

                    class_type = self._get_from_sys_modules(other)

                    # Invoke recursive call for the class

                    self._attrs_help([class_type], module_name)

                # Fall back to enum style

                else:

                    enum = self._get_from_sys_modules(other)

                    # Split the docs into class docs and any attribute docs

                    class_doc, attr_docs = self._split_docs(enum)

                    print(&quot;  &quot; + enum.__name__ + f&quot; ({class_doc})&quot;)

                    info_dict = {}

                    for val in enum:

                        info_dict.update(

                            self._match_attribute_docs(

                                attr_name=val.name,

                                attr_docs=attr_docs,

                                attr_type_str=type(val.value).__name__,

                            )

                        )

                    self._handle_attributes_print(info_dict=info_dict)



        @abstractmethod

        def _extract_fnc(self, val, module_name):

            &quot;&quot;&quot;Function that gets the nested lists within classes



            *Args*:



                val: current attr

                module_name: matching module name



            *Returns*:



                list of any nested classes/enums



            &quot;&quot;&quot;



        @staticmethod

        def _get_from_sys_modules(cls_name):

            &quot;&quot;&quot;Gets the class from a dot notation name



            *Args*:



                cls_name: dot notation enum name



            *Returns*:



                module: enum class



            &quot;&quot;&quot;

            # Split on dot notation

            split_string = cls_name.split(&quot;.&quot;)

            module = None

            for idx, val in enumerate(split_string):

                # idx = 0 will always be a call to the sys.modules dict

                if idx == 0:

                    module = sys.modules[val]

                # all other idx are paths along the module that need to be traversed

                # idx = -1 will always be the final Enum object name we want to grab (final getattr call)

                else:

                    module = getattr(module, val)

            return module





    class AttrBuilder(BaseBuilder):

        &quot;&quot;&quot;Attr specific builder



        Class that handles building for the attr backend



        *Attributes*



            input_classes: list of input classes that link to a backend

            _configs: None or List of configs to read from

            _create_save_path: boolean to make the path to save to

            _desc: description for the arg parser

            _no_cmd_line: flag to force no command line reads

            save_path: list of path(s) to save the configs to



        &quot;&quot;&quot;



        def __init__(self, *args, **kwargs):

            &quot;&quot;&quot;AttrBuilder init



            Args:

                *args: list of input classes that link to a backend

                configs: None or List of configs to read from

                desc: description for the arg parser

                no_cmd_line: flag to force no command line reads

                **kwargs: any extra keyword args

            &quot;&quot;&quot;

            super().__init__(*args, module_name=&quot;spock.backend.config&quot;, **kwargs)



        @staticmethod

        def _make_group_override_parser(parser, class_obj, class_name):

            &quot;&quot;&quot;Makes a name specific override parser for a given class obj



            Takes a class object of the backend and adds a new argument group with argument names given with name

            Class.name so that individual parameters specific to a class can be overridden.



            *Args*:



                parser: argument parser

                class_obj: instance of a backend class

                class_name: used for module matching



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;

            attr_name = class_obj.__name__

            group_parser = parser.add_argument_group(

                title=str(attr_name) + &quot; Specific Overrides&quot;

            )

            for val in class_obj.__attrs_attrs__:

                val_type = val.metadata[&quot;type&quot;] if &quot;type&quot; in val.metadata else val.type

                # Check if the val type has __args__ -- this catches lists?

                # TODO (ncilfone): Fix up this super super ugly logic

                if (

                    hasattr(val_type, &quot;__args__&quot;)

                    and ((list(set(val_type.__args__))[0]).__module__ == class_name)

                    and attr.has((list(set(val_type.__args__))[0]))

                ):

                    args = list(set(val_type.__args__))[0]

                    for inner_val in args.__attrs_attrs__:

                        arg_name = f&quot;--{str(attr_name)}.{val.name}.{args.__name__}.{inner_val.name}&quot;

                        group_parser = make_argument(

                            arg_name, List[inner_val.type], group_parser

                        )

                # If it&#39;s a reference to a class it needs to be an arg of a simple string as class matching will take care

                # of it later on

                elif val_type.__module__ == &quot;spock.backend.config&quot;:

                    arg_name = f&quot;--{str(attr_name)}.{val.name}&quot;

                    val_type = str

                    group_parser = make_argument(arg_name, val_type, group_parser)

                else:

                    arg_name = f&quot;--{str(attr_name)}.{val.name}&quot;

                    group_parser = make_argument(arg_name, val_type, group_parser)

            return parser



        def _handle_arguments(self, args, class_obj):

            attr_name = class_obj.__name__

            class_names = [val.__name__ for val in self.input_classes]

            # Handle repeated classes

            if (

                attr_name in class_names

                and attr_name in args

                and isinstance(args[attr_name], list)

            ):

                fields = self._handle_repeated(args[attr_name], attr_name, class_names)

            # Handle non-repeated classes

            else:

                fields = {}

                for val in class_obj.__attrs_attrs__:

                    # Check if namespace is named and then check for key -- checking for local class def

                    if attr_name in args and val.name in args[attr_name]:

                        fields[val.name] = self._handle_nested_class(

                            args, args[attr_name][val.name], class_names

                        )

                    # If not named then just check for keys -- checking for global def

                    elif val.name in args:

                        fields[val.name] = self._handle_nested_class(

                            args, args[val.name], class_names

                        )

                    # Check for special keys to set

                    if (

                        &quot;special_key&quot; in val.metadata

                        and val.metadata[&quot;special_key&quot;] is not None

                    ):

                        if val.name in args:

                            self.save_path = args[val.name]

                        elif val.default is not None:

                            self.save_path = val.default

            return fields



        def _handle_repeated(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles repeated classes as lists



            *Args*:



                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                list of input_class[match)idx[0]] types filled with repeated values



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            return [self.input_classes[match_idx[0]](**val) for val in args]



        def _handle_nested_class(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles passing another class to the field dictionary



            *Args*:

                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                either the check_value or the necessary class



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            # If so then create the needed class object by unrolling the args to **kwargs and return it

            if len(match_idx) &gt; 0:

                if len(match_idx) &gt; 1:

                    raise ValueError(

                        &quot;Match error -- multiple classes with the same name definition&quot;

                    )

                else:

                    if (args.get(self.input_classes[match_idx[0]].__name__) is None) and (

                        check_value not in class_names

                    ):

                        raise ValueError(

                            f&quot;Cannot map a definition for the referenced class &quot;

                            f&quot;{self.input_classes[match_idx[0]].__name__}&quot;

                        )

                    current_arg = args.get(self.input_classes[match_idx[0]].__name__, {})

                    if isinstance(current_arg, list):

                        class_value = [

                            self.input_classes[match_idx[0]](**val) for val in current_arg

                        ]

                    else:

                        recurse_args = (

                            self._handle_recursive_defaults(

                                args.get(check_value), args, class_names

                            )

                            if check_value in args

                            else {}

                        )

                        class_value = self.input_classes[match_idx[0]](**recurse_args)

                return_value = class_value

            # else return the expected value

            else:

                return_value = check_value

            return return_value



        def _extract_fnc(self, val, module_name):

            &quot;&quot;&quot;Function that gets the nested lists within classes



            *Args*:



                val: current attr

                module_name: matching module name



            *Returns*:



                list of any nested classes/enums



            &quot;&quot;&quot;

            return (

                self._extract_other_types(val.metadata[&quot;type&quot;], module_name)

                if &quot;type&quot; in val.metadata

                else []

            )
</code></pre></div>
<h2 id="classes">Classes</h2>
<h3 id="attrbuilder">AttrBuilder</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">AttrBuilder</span><span class="p">(</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>??? example "View Source"
        class AttrBuilder(BaseBuilder):</p>
<div class="highlight"><pre><span></span><code>        &quot;&quot;&quot;Attr specific builder



        Class that handles building for the attr backend



        *Attributes*



            input_classes: list of input classes that link to a backend

            _configs: None or List of configs to read from

            _create_save_path: boolean to make the path to save to

            _desc: description for the arg parser

            _no_cmd_line: flag to force no command line reads

            save_path: list of path(s) to save the configs to



        &quot;&quot;&quot;



        def __init__(self, *args, **kwargs):

            &quot;&quot;&quot;AttrBuilder init



            Args:

                *args: list of input classes that link to a backend

                configs: None or List of configs to read from

                desc: description for the arg parser

                no_cmd_line: flag to force no command line reads

                **kwargs: any extra keyword args

            &quot;&quot;&quot;

            super().__init__(*args, module_name=&quot;spock.backend.config&quot;, **kwargs)



        @staticmethod

        def _make_group_override_parser(parser, class_obj, class_name):

            &quot;&quot;&quot;Makes a name specific override parser for a given class obj



            Takes a class object of the backend and adds a new argument group with argument names given with name

            Class.name so that individual parameters specific to a class can be overridden.



            *Args*:



                parser: argument parser

                class_obj: instance of a backend class

                class_name: used for module matching



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;

            attr_name = class_obj.__name__

            group_parser = parser.add_argument_group(

                title=str(attr_name) + &quot; Specific Overrides&quot;

            )

            for val in class_obj.__attrs_attrs__:

                val_type = val.metadata[&quot;type&quot;] if &quot;type&quot; in val.metadata else val.type

                # Check if the val type has __args__ -- this catches lists?

                # TODO (ncilfone): Fix up this super super ugly logic

                if (

                    hasattr(val_type, &quot;__args__&quot;)

                    and ((list(set(val_type.__args__))[0]).__module__ == class_name)

                    and attr.has((list(set(val_type.__args__))[0]))

                ):

                    args = list(set(val_type.__args__))[0]

                    for inner_val in args.__attrs_attrs__:

                        arg_name = f&quot;--{str(attr_name)}.{val.name}.{args.__name__}.{inner_val.name}&quot;

                        group_parser = make_argument(

                            arg_name, List[inner_val.type], group_parser

                        )

                # If it&#39;s a reference to a class it needs to be an arg of a simple string as class matching will take care

                # of it later on

                elif val_type.__module__ == &quot;spock.backend.config&quot;:

                    arg_name = f&quot;--{str(attr_name)}.{val.name}&quot;

                    val_type = str

                    group_parser = make_argument(arg_name, val_type, group_parser)

                else:

                    arg_name = f&quot;--{str(attr_name)}.{val.name}&quot;

                    group_parser = make_argument(arg_name, val_type, group_parser)

            return parser



        def _handle_arguments(self, args, class_obj):

            attr_name = class_obj.__name__

            class_names = [val.__name__ for val in self.input_classes]

            # Handle repeated classes

            if (

                attr_name in class_names

                and attr_name in args

                and isinstance(args[attr_name], list)

            ):

                fields = self._handle_repeated(args[attr_name], attr_name, class_names)

            # Handle non-repeated classes

            else:

                fields = {}

                for val in class_obj.__attrs_attrs__:

                    # Check if namespace is named and then check for key -- checking for local class def

                    if attr_name in args and val.name in args[attr_name]:

                        fields[val.name] = self._handle_nested_class(

                            args, args[attr_name][val.name], class_names

                        )

                    # If not named then just check for keys -- checking for global def

                    elif val.name in args:

                        fields[val.name] = self._handle_nested_class(

                            args, args[val.name], class_names

                        )

                    # Check for special keys to set

                    if (

                        &quot;special_key&quot; in val.metadata

                        and val.metadata[&quot;special_key&quot;] is not None

                    ):

                        if val.name in args:

                            self.save_path = args[val.name]

                        elif val.default is not None:

                            self.save_path = val.default

            return fields



        def _handle_repeated(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles repeated classes as lists



            *Args*:



                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                list of input_class[match)idx[0]] types filled with repeated values



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            return [self.input_classes[match_idx[0]](**val) for val in args]



        def _handle_nested_class(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles passing another class to the field dictionary



            *Args*:

                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                either the check_value or the necessary class



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            # If so then create the needed class object by unrolling the args to **kwargs and return it

            if len(match_idx) &gt; 0:

                if len(match_idx) &gt; 1:

                    raise ValueError(

                        &quot;Match error -- multiple classes with the same name definition&quot;

                    )

                else:

                    if (args.get(self.input_classes[match_idx[0]].__name__) is None) and (

                        check_value not in class_names

                    ):

                        raise ValueError(

                            f&quot;Cannot map a definition for the referenced class &quot;

                            f&quot;{self.input_classes[match_idx[0]].__name__}&quot;

                        )

                    current_arg = args.get(self.input_classes[match_idx[0]].__name__, {})

                    if isinstance(current_arg, list):

                        class_value = [

                            self.input_classes[match_idx[0]](**val) for val in current_arg

                        ]

                    else:

                        recurse_args = (

                            self._handle_recursive_defaults(

                                args.get(check_value), args, class_names

                            )

                            if check_value in args

                            else {}

                        )

                        class_value = self.input_classes[match_idx[0]](**recurse_args)

                return_value = class_value

            # else return the expected value

            else:

                return_value = check_value

            return return_value



        def _extract_fnc(self, val, module_name):

            &quot;&quot;&quot;Function that gets the nested lists within classes



            *Args*:



                val: current attr

                module_name: matching module name



            *Returns*:



                list of any nested classes/enums



            &quot;&quot;&quot;

            return (

                self._extract_other_types(val.metadata[&quot;type&quot;], module_name)

                if &quot;type&quot; in val.metadata

                else []

            )
</code></pre></div>
<hr />
<h4 id="ancestors-in-mro">Ancestors (in MRO)</h4>
<ul>
<li>spock.backend.builder.BaseBuilder</li>
<li>abc.ABC</li>
</ul>
<h4 id="methods">Methods</h4>
<h4 id="build_override_parsers">build_override_parsers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">build_override_parsers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">parser</span>
<span class="p">)</span>
</code></pre></div>
<p>Creates parsers for command-line overrides</p>
<p>Builds the basic command line parser for configs and help then iterates through each attr instance to make
namespace specific cmd line override parsers</p>
<p><em>Args</em>:</p>
<div class="highlight"><pre><span></span><code>parser: argument parser
</code></pre></div>
<p><em>Returns</em>:</p>
<div class="highlight"><pre><span></span><code>parser: argument parser with new class specific overrides
</code></pre></div>
<p>??? example "View Source"
            def build_override_parsers(self, parser):</p>
<div class="highlight"><pre><span></span><code>            &quot;&quot;&quot;Creates parsers for command-line overrides



            Builds the basic command line parser for configs and help then iterates through each attr instance to make

            namespace specific cmd line override parsers



            *Args*:



                parser: argument parser



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;

            # Build out each class override specific parser

            for val in self.input_classes:

                parser = self._make_group_override_parser(

                    parser=parser, class_obj=val, class_name=self._module_name

                )

            return parser
</code></pre></div>
<h4 id="generate">generate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dict_args</span>
<span class="p">)</span>
</code></pre></div>
<p>Method to auto-generate the actual class instances from the generated args</p>
<p>Based on the generated arguments groups and the args read in from the config file(s)
this function instantiates the classes with the necessary field or attr values</p>
<p><em>Args</em>:</p>
<div class="highlight"><pre><span></span><code>dict_args: dictionary of arguments from the configs
</code></pre></div>
<p><em>Returns</em>:</p>
<div class="highlight"><pre><span></span><code>namespace containing automatically generated instances of the classes
</code></pre></div>
<p>??? example "View Source"
            def generate(self, dict_args):</p>
<div class="highlight"><pre><span></span><code>            &quot;&quot;&quot;Method to auto-generate the actual class instances from the generated args



            Based on the generated arguments groups and the args read in from the config file(s)

            this function instantiates the classes with the necessary field or attr values



            *Args*:



                dict_args: dictionary of arguments from the configs



            *Returns*:



                namespace containing automatically generated instances of the classes

            &quot;&quot;&quot;

            auto_dict = {}

            for attr_classes in self.input_classes:

                attr_build = self._auto_generate(dict_args, attr_classes)

                if isinstance(attr_build, list):

                    class_name = list({type(val).__name__ for val in attr_build})

                    if len(class_name) &gt; 1:

                        raise ValueError(&quot;Repeated class has more than one unique name&quot;)

                    auto_dict.update({class_name[0]: attr_build})

                else:

                    auto_dict.update({type(attr_build).__name__: attr_build})

            return Spockspace(**auto_dict)
</code></pre></div>
<h4 id="handle_help_info">handle_help_info</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">handle_help_info</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Handles walking through classes to get help info</p>
<p>For each class this function will search <strong>doc</strong> and attempt to pull out help information for both the class
itself and each attribute within the class</p>
<p><em>Returns</em>:</p>
<div class="highlight"><pre><span></span><code>None
</code></pre></div>
<p>??? example "View Source"
            def handle_help_info(self):</p>
<div class="highlight"><pre><span></span><code>            &quot;&quot;&quot;Handles walking through classes to get help info



            For each class this function will search __doc__ and attempt to pull out help information for both the class

            itself and each attribute within the class



            *Returns*:



                None



            &quot;&quot;&quot;

            self._attrs_help(self.input_classes, self._module_name)
</code></pre></div>
<h3 id="basebuilder">BaseBuilder</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BaseBuilder</span><span class="p">(</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">max_indent</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">module_name</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>??? example "View Source"
        class BaseBuilder(ABC):  # pylint: disable=too-few-public-methods</p>
<div class="highlight"><pre><span></span><code>        &quot;&quot;&quot;Base class for building the backend specific builders



        This class handles the interface to the backend with the generic ConfigArgBuilder so that different

        backends can be used to handle processing



        *Attributes*



            input_classes: list of input classes that link to a backend

            _configs: None or List of configs to read from

            _desc: description for the arg parser

            _no_cmd_line: flag to force no command line reads

            _max_indent: maximum to indent between help prints

            save_path: list of path(s) to save the configs to



        &quot;&quot;&quot;



        def __init__(self, *args, max_indent=4, module_name, **kwargs):

            self.input_classes = args

            self._module_name = module_name

            self._max_indent = max_indent

            self.save_path = None



        @staticmethod

        @abstractmethod

        def _make_group_override_parser(parser, class_obj, class_name):

            &quot;&quot;&quot;Makes a name specific override parser for a given class obj



            Takes a class object of the backend and adds a new argument group with argument names given with name

            Class.name so that individual parameters specific to a class can be overridden.



            *Args*:



                parser: argument parser

                class_obj: instance of a backend class

                class_name: used for module matching



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;



        def handle_help_info(self):

            &quot;&quot;&quot;Handles walking through classes to get help info



            For each class this function will search __doc__ and attempt to pull out help information for both the class

            itself and each attribute within the class



            *Returns*:



                None



            &quot;&quot;&quot;

            self._attrs_help(self.input_classes, self._module_name)



        def _handle_arguments(self, args, class_obj):

            &quot;&quot;&quot;Handles all argument mapping



            Creates a dictionary of named parameters that are mapped to the final type of object



            *Args*:



                args: read file arguments

                class_obj: instance of a class obj



            *Returns*:



                fields: dictionary of mapped parameters



            &quot;&quot;&quot;

            attr_name = class_obj.__name__

            class_names = [val.__name__ for val in self.input_classes]

            # Handle repeated classes

            if (

                attr_name in class_names

                and attr_name in args

                and isinstance(args[attr_name], list)

            ):

                fields = self._handle_repeated(args[attr_name], attr_name, class_names)

            # Handle non-repeated classes

            else:

                fields = {}

                for val in class_obj.__attrs_attrs__:

                    # Check if namespace is named and then check for key -- checking for local class def

                    if attr_name in args and val.name in args[attr_name]:

                        fields[val.name] = self._handle_nested_class(

                            args, args[attr_name][val.name], class_names

                        )

                    # If not named then just check for keys -- checking for global def

                    elif val.name in args:

                        fields[val.name] = self._handle_nested_class(

                            args, args[val.name], class_names

                        )

                    # Check for special keys to set

                    if (

                        &quot;special_key&quot; in val.metadata

                        and val.metadata[&quot;special_key&quot;] is not None

                    ):

                        if val.name in args:

                            self.save_path = args[val.name]

                        elif val.default is not None:

                            self.save_path = val.default

            return fields



        def _handle_repeated(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles repeated classes as lists



            *Args*:



                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                list of input_class[match)idx[0]] types filled with repeated values



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            return [self.input_classes[match_idx[0]](**val) for val in args]



        def _handle_nested_class(self, args, check_value, class_names):

            &quot;&quot;&quot;Handles passing another class to the field dictionary



            *Args*:

                args: dictionary of arguments from the configs

                check_value: value to check classes against

                class_names: current class names



            *Returns*:



                either the check_value or the necessary class



            &quot;&quot;&quot;

            # Check to see if the value trying to be set is actually an input class

            match_idx = [idx for idx, val in enumerate(class_names) if val == check_value]

            # If so then create the needed class object by unrolling the args to **kwargs and return it

            if len(match_idx) &gt; 0:

                if len(match_idx) &gt; 1:

                    raise ValueError(

                        &quot;Match error -- multiple classes with the same name definition&quot;

                    )

                else:

                    if args.get(self.input_classes[match_idx[0]].__name__) is None:

                        raise ValueError(

                            f&quot;Missing config file definition for the referenced class &quot;

                            f&quot;{self.input_classes[match_idx[0]].__name__}&quot;

                        )

                    current_arg = args.get(self.input_classes[match_idx[0]].__name__)

                    if isinstance(current_arg, list):

                        class_value = [

                            self.input_classes[match_idx[0]](**val) for val in current_arg

                        ]

                    else:

                        class_value = self.input_classes[match_idx[0]](**current_arg)

                return_value = class_value

            # else return the expected value

            else:

                return_value = check_value

            return return_value



        def generate(self, dict_args):

            &quot;&quot;&quot;Method to auto-generate the actual class instances from the generated args



            Based on the generated arguments groups and the args read in from the config file(s)

            this function instantiates the classes with the necessary field or attr values



            *Args*:



                dict_args: dictionary of arguments from the configs



            *Returns*:



                namespace containing automatically generated instances of the classes

            &quot;&quot;&quot;

            auto_dict = {}

            for attr_classes in self.input_classes:

                attr_build = self._auto_generate(dict_args, attr_classes)

                if isinstance(attr_build, list):

                    class_name = list({type(val).__name__ for val in attr_build})

                    if len(class_name) &gt; 1:

                        raise ValueError(&quot;Repeated class has more than one unique name&quot;)

                    auto_dict.update({class_name[0]: attr_build})

                else:

                    auto_dict.update({type(attr_build).__name__: attr_build})

            return Spockspace(**auto_dict)



        def _auto_generate(self, args, input_class):

            &quot;&quot;&quot;Builds an instance of an attr class



            Builds an instance with the necessary field values from the argument

            dictionary read from the config file(s)



            *Args*:



                args: dictionary of arguments read from the config file(s)

                data_class: data class to build



            *Returns*:



                An instance of data_class with correct values assigned to fields

            &quot;&quot;&quot;

            # Handle the basic data types

            fields = self._handle_arguments(args, input_class)

            if isinstance(fields, list):

                return_value = fields

            else:

                self._handle_late_defaults(args, fields, input_class)

                return_value = input_class(**fields)

            return return_value



        def _handle_late_defaults(self, args, fields, input_class):

            &quot;&quot;&quot;Handles late defaults when the type is non-standard



            If the default type is not a base python type then we need to catch those defaults here and build the correct

            values from the input classes while maintaining the optional nature. The trick is to exclude all &#39;base&#39; types

            as these defaults are covered by the attr default value



            *Args*:



                args: dictionary of arguments read from the config file(s)

                fields: current fields returned from _handle_arguments

                input_class: which input class being checked for late defaults



            *Returns*:



                fields: updated field dictionary with late defaults set



            &quot;&quot;&quot;

            names = [val.name for val in input_class.__attrs_attrs__]

            class_names = [val.__name__ for val in self.input_classes]

            field_list = list(fields.keys())

            arg_list = list(args.keys())

            # Exclude all the base types that are supported -- these can be set by attrs

            exclude_list = [

                &quot;_Nothing&quot;,

                &quot;NoneType&quot;,

                &quot;bool&quot;,

                &quot;int&quot;,

                &quot;float&quot;,

                &quot;str&quot;,

                &quot;list&quot;,

                &quot;tuple&quot;,

            ]

            for val in names:

                if val not in field_list:

                    # Gets the name of the class to default to

                    default_type_name = type(

                        getattr(input_class.__attrs_attrs__, val).default

                    ).__name__

                    if default_type_name not in exclude_list:

                        # Gets the default class object

                        default_attr = getattr(input_class.__attrs_attrs__, val).default

                        # If the default is given for a class then it&#39;s the actual class and not a type -- logic needs

                        # to deal with both

                        if type(default_attr).__name__ == &quot;type&quot;:

                            default_name = default_attr.__name__

                        else:

                            default_name = type(default_attr).__name__

                    # Skip if in the exclude list

                    else:

                        default_name = None

                    # if we need to fall back onto the default and ff it&#39;s in the arg_list then we have a

                    # definition coming in from the config file

                    if default_name is not None and default_name in arg_list:

                        # This handles lists of class type repeats -- these cannot be nested as the logic would be too

                        # confusing to map to

                        if isinstance(args.get(default_name), list):

                            default_value = [

                                self.input_classes[class_names.index(default_name)](

                                    **arg_val

                                )

                                for arg_val in args.get(default_name)

                            ]

                        # This handles basics and references to other classes -- here we need to recurse to grab any nested

                        # defs since classes are passed as strings to the config but are defined via Enums (handled #139)

                        else:

                            recurse_args = self._handle_recursive_defaults(

                                args.get(default_name), args, class_names

                            )

                            default_value = self.input_classes[

                                class_names.index(default_name)

                            ](**recurse_args)

                        fields.update({val: default_value})

            return fields



        def _handle_recursive_defaults(self, curr_arg, all_args, class_names):

            &quot;&quot;&quot;Recurses through the args from the config read to determine if it can map to a definition



            *Args*:



                curr_arg: current argument

                all_args: all argument dictionary

                class_names: list of class names



            *Returns*:



                out_dict: recursively mapped dictionary of attributes



            &quot;&quot;&quot;

            out_dict = {}

            for k, v in curr_arg.items():

                # If the value is a reference to another class we need to recurse

                if v in class_names:

                    # Recurse only if in the all_args dict (from the config file)

                    if v in all_args:

                        bubbled_dict = self._handle_recursive_defaults(

                            all_args.get(v), all_args, class_names

                        )

                        out_dict.update(

                            {k: self.input_classes[class_names.index(v)](**bubbled_dict)}

                        )

                    # Else fall back on default instantiation

                    else:

                        out_dict.update({k: self.input_classes[class_names.index(v)]()})

                else:

                    out_dict.update({k: v})

            return out_dict



        def build_override_parsers(self, parser):

            &quot;&quot;&quot;Creates parsers for command-line overrides



            Builds the basic command line parser for configs and help then iterates through each attr instance to make

            namespace specific cmd line override parsers



            *Args*:



                parser: argument parser



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;

            # Build out each class override specific parser

            for val in self.input_classes:

                parser = self._make_group_override_parser(

                    parser=parser, class_obj=val, class_name=self._module_name

                )

            return parser



        @staticmethod

        def _get_from_kwargs(args, configs):

            &quot;&quot;&quot;Get configs from the configs kwarg



            *Args*:



                args: argument namespace

                configs: config kwarg



            *Returns*:



                args: arg namespace



            &quot;&quot;&quot;

            if isinstance(configs, list):

                args.config.extend(configs)

            else:

                raise TypeError(

                    f&quot;configs kwarg must be of type list -- given {type(configs)}&quot;

                )

            return args



        @staticmethod

        def _find_attribute_idx(newline_split_docs):

            &quot;&quot;&quot;Finds the possible split between the header and Attribute annotations



            *Args*:



                newline_split_docs: new line split text



            Returns:



                idx: -1 if none or the idx of Attributes



            &quot;&quot;&quot;

            for idx, val in enumerate(newline_split_docs):

                re_check = re.search(r&quot;(?i)Attribute?s?:&quot;, val)

                if re_check is not None:

                    return idx

            return -1



        def _split_docs(self, obj):

            &quot;&quot;&quot;Possibly splits head class doc string from attribute docstrings



            Attempts to find the first contiguous line within the Google style docstring to use as the class docstring.

            Splits the docs base on the Attributes tag if present.



            *Args*:



                obj: class object to rip info from



            *Returns*:



                class_doc: class docstring if present or blank str

                attr_doc: list of attribute doc strings



            &quot;&quot;&quot;

            if obj.__doc__ is not None:

                # Split by new line

                newline_split_docs = obj.__doc__.split(&quot;\n&quot;)

                # Cleanup l/t whitespace

                newline_split_docs = [val.strip() for val in newline_split_docs]

            else:

                newline_split_docs = []

            # Find the break between the class docs and the Attribute section -- if this returns -1 then there is no

            # Attributes section

            attr_idx = self._find_attribute_idx(newline_split_docs)

            head_docs = (

                newline_split_docs[:attr_idx] if attr_idx != -1 else newline_split_docs

            )

            attr_docs = newline_split_docs[attr_idx:] if attr_idx != -1 else []

            # Grab only the first contiguous line as everything else will probably be too verbose (e.g. the

            # mid-level docstring that has detailed descriptions

            class_doc = &quot;&quot;

            for idx, val in enumerate(head_docs):

                class_doc += f&quot; {val}&quot;

                if idx + 1 != len(head_docs) and head_docs[idx + 1] == &quot;&quot;:

                    break

            # Clean up any l/t whitespace

            class_doc = class_doc.strip()

            if len(class_doc) &gt; 0:

                class_doc = f&quot;-- {class_doc}&quot;

            return class_doc, attr_docs



        @staticmethod

        def _match_attribute_docs(

            attr_name, attr_docs, attr_type_str, attr_default=NOTHING

        ):

            &quot;&quot;&quot;Matches class attributes with attribute docstrings via regex



            *Args*:



                attr_name: attribute name

                attr_docs: list of attribute docstrings

                attr_type_str: str representation of the attribute type

                attr_default: str representation of a possible default value



            *Returns*:



                dictionary of packed attribute information



            &quot;&quot;&quot;

            # Regex match each value

            a_str = None

            for a_doc in attr_docs:

                match_re = re.search(r&quot;(?i)^&quot; + attr_name + &quot;?:&quot;, a_doc)

                # Find only the first match -- if more than one than ignore

                if match_re:

                    a_str = a_doc[match_re.end() :].strip()

            return {

                attr_name: {

                    &quot;type&quot;: attr_type_str,

                    &quot;desc&quot;: a_str if a_str is not None else &quot;&quot;,

                    &quot;default&quot;: &quot;(default: &quot; + repr(attr_default) + &quot;)&quot;

                    if type(attr_default).__name__ != &quot;_Nothing&quot;

                    else &quot;&quot;,

                    &quot;len&quot;: {&quot;name&quot;: len(attr_name), &quot;type&quot;: len(attr_type_str)},

                }

            }



        def _handle_attributes_print(self, info_dict):

            &quot;&quot;&quot;Prints attribute information in an argparser style format



            *Args*:



                info_dict: packed attribute info dictionary to print



            &quot;&quot;&quot;

            # Figure out indents

            max_param_length = max([len(k) for k in info_dict.keys()])

            max_type_length = max([v[&quot;len&quot;][&quot;type&quot;] for v in info_dict.values()])

            # Print akin to the argparser

            for k, v in info_dict.items():

                print(

                    f&quot;    {k}&quot;

                    + (&quot; &quot; * (max_param_length - v[&quot;len&quot;][&quot;name&quot;] + self._max_indent))

                    + f&#39;{v[&quot;type&quot;]}&#39;

                    + (&quot; &quot; * (max_type_length - v[&quot;len&quot;][&quot;type&quot;] + self._max_indent))

                    + f&#39;{v[&quot;desc&quot;]} {v[&quot;default&quot;]}&#39;

                )

            # Blank for spacing :-/

            print(&quot;&quot;)



        def _extract_other_types(self, typed, module_name):

            &quot;&quot;&quot;Takes a high level type and recursively extracts any enum or class types



            *Args*:



                typed: highest level type

                module_name: name of module to match



            *Returns*:



                return_list: list of nums (dot notation of module_path.enum_name or module_path.class_name)



            &quot;&quot;&quot;

            return_list = []

            if hasattr(typed, &quot;__args__&quot;):

                for val in typed.__args__:

                    recurse_return = self._extract_other_types(val, module_name)

                    if isinstance(recurse_return, list):

                        return_list.extend(recurse_return)

                    else:

                        return_list.append(self._extract_other_types(val, module_name))

            elif isinstance(typed, EnumMeta) or (typed.__module__ == module_name):

                return [f&quot;{typed.__module__}.{typed.__name__}&quot;]

            return return_list



        def _attrs_help(self, input_classes, module_name):

            &quot;&quot;&quot;Handles walking through a list classes to get help info



            For each class this function will search __doc__ and attempt to pull out help information for both the class

            itself and each attribute within the class. If it finds a repeated class in a iterable object it will

            recursively call self to handle information



            *Args*:



                input_classes: list of attr classes

                module_name: name of module to match



            *Returns*:



                None



            &quot;&quot;&quot;

            # Handle the main loop

            other_list = self._handle_help_main(input_classes, module_name)

            self._handle_help_enums(other_list=other_list, module_name=module_name)



        @staticmethod

        def _get_type_string(val, nested_others):

            &quot;&quot;&quot;Gets the type of the attr val as a string



            *Args*:



                val: current attr being processed

                nested_others: list of nested others to deal with that might have module path info in the string



            *Returns*:



                type_string: type of the attr as a str



            &quot;&quot;&quot;

            # Grab the base or type info depending on what is provided

            if &quot;type&quot; in val.metadata:

                type_string = repr(val.metadata[&quot;type&quot;])

            elif &quot;base&quot; in val.metadata:

                type_string = val.metadata[&quot;base&quot;]

            elif hasattr(val.type, &quot;__name__&quot;):

                type_string = val.type.__name__

            else:

                type_string = str(val.type)

            # Regex out the typing info if present

            type_string = re.sub(r&quot;typing.&quot;, &quot;&quot;, type_string)

            # Regex out any nested_others that have module path information

            for other_val in nested_others:

                split_other = f&quot;{&#39;.&#39;.join(other_val.split(&#39;.&#39;)[:-1])}.&quot;

                type_string = re.sub(split_other, &quot;&quot;, type_string)

            # Regex the string to see if it matches any Enums in the __main__ module space

            # Construct the type with the metadata

            if &quot;optional&quot; in val.metadata:

                type_string = f&quot;Optional[{type_string}]&quot;

            return type_string



        def _handle_help_main(self, input_classes, module_name):

            &quot;&quot;&quot;Handles the print of the main class types



            *Args*:



                input_classes: current set of input classes

                module_name: module name to match



            *Returns*:



                other_list: extended list of other classes/enums to process



            &quot;&quot;&quot;

            # List to catch Enums and classes and handle post spock wrapped attr classes

            other_list = []

            covered_set = set()

            for attrs_class in input_classes:

                # Split the docs into class docs and any attribute docs

                class_doc, attr_docs = self._split_docs(attrs_class)

                print(&quot;  &quot; + attrs_class.__name__ + f&quot; {class_doc}&quot;)

                # Keep a running info_dict of all the attribute level info

                info_dict = {}

                for val in attrs_class.__attrs_attrs__:

                    # If the type is an enum we need to handle it outside of this attr loop

                    # Match the style of nested enums and return a string of module.name notation

                    if isinstance(val.type, EnumMeta):

                        other_list.append(f&quot;{val.type.__module__}.{val.type.__name__}&quot;)

                    # if there is a type (implied Iterable) -- check it for nested Enums or classes

                    nested_others = self._extract_fnc(val, module_name)

                    if len(nested_others) &gt; 0:

                        other_list.extend(nested_others)

                    # Get the type represented as a string

                    type_string = self._get_type_string(val, nested_others)

                    info_dict.update(

                        self._match_attribute_docs(

                            val.name, attr_docs, type_string, val.default

                        )

                    )

                # Add to covered so we don&#39;t print help twice in the case of some recursive nesting

                covered_set.add(f&quot;{attrs_class.__module__}.{attrs_class.__name__}&quot;)

                self._handle_attributes_print(info_dict=info_dict)

            # Convert the enum list to a set to remove dupes and then back to a list so it is iterable -- set diff to not

            # repeat

            return list(set(other_list) - covered_set)



        def _handle_help_enums(self, other_list, module_name):

            &quot;&quot;&quot;handles any extra enums from non main args



            *Args*:



                other_list: extended list of other classes/enums to process

                module_name: module name to match



            *Returns*:



                None



            &quot;&quot;&quot;

            # Iterate any Enum type classes

            for other in other_list:

                # if it&#39;s longer than 2 then it&#39;s an embedded Spock class

                if &quot;.&quot;.join(other.split(&quot;.&quot;)[:-1]) == module_name:

                    class_type = self._get_from_sys_modules(other)

                    # Invoke recursive call for the class

                    self._attrs_help([class_type], module_name)

                # Fall back to enum style

                else:

                    enum = self._get_from_sys_modules(other)

                    # Split the docs into class docs and any attribute docs

                    class_doc, attr_docs = self._split_docs(enum)

                    print(&quot;  &quot; + enum.__name__ + f&quot; ({class_doc})&quot;)

                    info_dict = {}

                    for val in enum:

                        info_dict.update(

                            self._match_attribute_docs(

                                attr_name=val.name,

                                attr_docs=attr_docs,

                                attr_type_str=type(val.value).__name__,

                            )

                        )

                    self._handle_attributes_print(info_dict=info_dict)



        @abstractmethod

        def _extract_fnc(self, val, module_name):

            &quot;&quot;&quot;Function that gets the nested lists within classes



            *Args*:



                val: current attr

                module_name: matching module name



            *Returns*:



                list of any nested classes/enums



            &quot;&quot;&quot;



        @staticmethod

        def _get_from_sys_modules(cls_name):

            &quot;&quot;&quot;Gets the class from a dot notation name



            *Args*:



                cls_name: dot notation enum name



            *Returns*:



                module: enum class



            &quot;&quot;&quot;

            # Split on dot notation

            split_string = cls_name.split(&quot;.&quot;)

            module = None

            for idx, val in enumerate(split_string):

                # idx = 0 will always be a call to the sys.modules dict

                if idx == 0:

                    module = sys.modules[val]

                # all other idx are paths along the module that need to be traversed

                # idx = -1 will always be the final Enum object name we want to grab (final getattr call)

                else:

                    module = getattr(module, val)

            return module
</code></pre></div>
<hr />
<h4 id="ancestors-in-mro_1">Ancestors (in MRO)</h4>
<ul>
<li>abc.ABC</li>
</ul>
<h4 id="descendants">Descendants</h4>
<ul>
<li>spock.backend.builder.AttrBuilder</li>
<li>spock.addons.tune.builder.TunerBuilder</li>
</ul>
<h4 id="methods_1">Methods</h4>
<h4 id="build_override_parsers_1">build_override_parsers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">build_override_parsers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">parser</span>
<span class="p">)</span>
</code></pre></div>
<p>Creates parsers for command-line overrides</p>
<p>Builds the basic command line parser for configs and help then iterates through each attr instance to make
namespace specific cmd line override parsers</p>
<p><em>Args</em>:</p>
<div class="highlight"><pre><span></span><code>parser: argument parser
</code></pre></div>
<p><em>Returns</em>:</p>
<div class="highlight"><pre><span></span><code>parser: argument parser with new class specific overrides
</code></pre></div>
<p>??? example "View Source"
            def build_override_parsers(self, parser):</p>
<div class="highlight"><pre><span></span><code>            &quot;&quot;&quot;Creates parsers for command-line overrides



            Builds the basic command line parser for configs and help then iterates through each attr instance to make

            namespace specific cmd line override parsers



            *Args*:



                parser: argument parser



            *Returns*:



                parser: argument parser with new class specific overrides



            &quot;&quot;&quot;

            # Build out each class override specific parser

            for val in self.input_classes:

                parser = self._make_group_override_parser(

                    parser=parser, class_obj=val, class_name=self._module_name

                )

            return parser
</code></pre></div>
<h4 id="generate_1">generate</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">generate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dict_args</span>
<span class="p">)</span>
</code></pre></div>
<p>Method to auto-generate the actual class instances from the generated args</p>
<p>Based on the generated arguments groups and the args read in from the config file(s)
this function instantiates the classes with the necessary field or attr values</p>
<p><em>Args</em>:</p>
<div class="highlight"><pre><span></span><code>dict_args: dictionary of arguments from the configs
</code></pre></div>
<p><em>Returns</em>:</p>
<div class="highlight"><pre><span></span><code>namespace containing automatically generated instances of the classes
</code></pre></div>
<p>??? example "View Source"
            def generate(self, dict_args):</p>
<div class="highlight"><pre><span></span><code>            &quot;&quot;&quot;Method to auto-generate the actual class instances from the generated args



            Based on the generated arguments groups and the args read in from the config file(s)

            this function instantiates the classes with the necessary field or attr values



            *Args*:



                dict_args: dictionary of arguments from the configs



            *Returns*:



                namespace containing automatically generated instances of the classes

            &quot;&quot;&quot;

            auto_dict = {}

            for attr_classes in self.input_classes:

                attr_build = self._auto_generate(dict_args, attr_classes)

                if isinstance(attr_build, list):

                    class_name = list({type(val).__name__ for val in attr_build})

                    if len(class_name) &gt; 1:

                        raise ValueError(&quot;Repeated class has more than one unique name&quot;)

                    auto_dict.update({class_name[0]: attr_build})

                else:

                    auto_dict.update({type(attr_build).__name__: attr_build})

            return Spockspace(**auto_dict)
</code></pre></div>
<h4 id="handle_help_info_1">handle_help_info</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">handle_help_info</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Handles walking through classes to get help info</p>
<p>For each class this function will search <strong>doc</strong> and attempt to pull out help information for both the class
itself and each attribute within the class</p>
<p><em>Returns</em>:</p>
<div class="highlight"><pre><span></span><code>None
</code></pre></div>
<p>??? example "View Source"
            def handle_help_info(self):</p>
<div class="highlight"><pre><span></span><code>            &quot;&quot;&quot;Handles walking through classes to get help info



            For each class this function will search __doc__ and attempt to pull out help information for both the class

            itself and each attribute within the class



            *Returns*:



                None



            &quot;&quot;&quot;

            self._attrs_help(self.input_classes, self._module_name)
</code></pre></div>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../../addons/tune/tuner/" title="Tuner" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Tuner
              </span>
            </div>
          </a>
        
        
          <a href="../config/" title="Config" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Config
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Powered by
        <a href="http://timothycrosley.github.io/portray">portray.</a>
        You too can
        <a href="http://timothycrosley.github.io/portray">
          portray</a>
        your Python project well using automatic documentation.
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../../../assets/javascripts/workers/search.f8263e09.min.js", "version": null}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.4fc53ad4.min.js"></script>
      
    
  </body>
</html>