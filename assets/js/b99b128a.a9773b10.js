"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[1957],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),o=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},c=function(e){var t=o(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=o(n),f=a,k=d["".concat(s,".").concat(f)]||d[f]||u[f]||l;return n?r.createElement(k,p(p({ref:t},c),{},{components:n})):r.createElement(k,p({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,p=new Array(l);p[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,p[1]=i;for(var o=2;o<l;o++)p[o]=n[o];return r.createElement.apply(null,p)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8676:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return o},toc:function(){return c},default:function(){return d}});var r=n(7462),a=n(3366),l=(n(7294),n(3905)),p=["components"],i={sidebar_label:"utils",title:"backend.utils"},s=void 0,o={unversionedId:"reference/backend/utils",id:"reference/backend/utils",isDocsHomePage:!1,title:"backend.utils",description:"Attr utility functions for Spock",source:"@site/docs/reference/backend/utils.md",sourceDirName:"reference/backend",slug:"/reference/backend/utils",permalink:"/spock/reference/backend/utils",editUrl:"https://github.com/fidelity/spock/edit/master/website/docs/reference/backend/utils.md",tags:[],version:"current",frontMatter:{sidebar_label:"utils",title:"backend.utils"},sidebar:"api",previous:{title:"typed",permalink:"/spock/reference/backend/typed"},next:{title:"wrappers",permalink:"/spock/reference/backend/wrappers"}},c=[],u={toc:c};function d(e){var t=e.components,n=(0,a.Z)(e,p);return(0,l.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Attr utility functions for Spock"),(0,l.kt)("h4",{id:"get_attr_fields"},"get","_","attr","_","fields"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def get_attr_fields(input_classes)\n")),(0,l.kt)("p",null,"Gets the attribute fields from all classes"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Args"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"input_classes: current list of input classes\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"dictionary of all attrs attribute fields\n")),(0,l.kt)("h4",{id:"get_type_fields"},"get","_","type","_","fields"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def get_type_fields(input_classes)\n")),(0,l.kt)("p",null,"Creates a dictionary of names and types"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Args"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"input_classes: list of input classes\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"type_fields: dictionary of names and types\n")),(0,l.kt)("h4",{id:"flatten_type_dict"},"flatten","_","type","_","dict"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def flatten_type_dict(type_dict)\n")),(0,l.kt)("p",null,"Flattens a nested dictionary"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Args"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"type_dict: dictionary of types that are generic\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"flat_dict: flatten dictionary to a single level\n")),(0,l.kt)("h4",{id:"convert_to_tuples"},"convert","_","to","_","tuples"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def convert_to_tuples(input_dict, named_type_dict, class_names)\n")),(0,l.kt)("p",null,"Convert lists to tuples"),(0,l.kt)("p",null,"Payloads from markup come in as Lists and not Tuples. This function turns lists in to tuples for the payloads\nso the attr values are set correctly. Will call itself recursively if a dictionary is present for class specific\nvalues"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Args"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"input_dict: input dictionary\nnamed_type_dict: dictionary of names with generic types\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"updated_dict: a dictionary with lists converted to tuples\n")),(0,l.kt)("h4",{id:"deep_update"},"deep","_","update"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def deep_update(source, updates)\n")),(0,l.kt)("p",null,"Deeply updates a dictionary"),(0,l.kt)("p",null,"Iterates through a dictionary recursively to update individual values within a possibly nested dictionary\nof dictionaries"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Args"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"source: source dictionary\nupdates: updates to the dictionary\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"source: updated version of the source dictionary\n")),(0,l.kt)("h4",{id:"_recursive_list_to_tuple"},"_","recursive","_","list","_","to","_","tuple"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def _recursive_list_to_tuple(key, value, typed, class_names)\n")),(0,l.kt)("p",null,"Recursively turn lists into tuples"),(0,l.kt)("p",null,"Recursively looks through a pair of value and type and sets any of the possibly nested type of value to tuple\nif tuple is the specified type"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Args"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"key: name of parameter\nvalue: value to check and set typ if necessary\ntyped: type of the generic alias to check against\nclass_names: list of all spock class names\n")),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Returns"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"value: updated value with correct type casts\n")))}d.isMDXComponent=!0}}]);