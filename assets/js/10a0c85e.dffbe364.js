"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[4054],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return k}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=s(n),k=l,m=d["".concat(p,".").concat(k)]||d[k]||u[k]||r;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function k(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8960:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return c},default:function(){return d}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],o={sidebar_label:"saver",title:"backend.saver"},p=void 0,s={unversionedId:"reference/backend/saver",id:"reference/backend/saver",isDocsHomePage:!1,title:"backend.saver",description:"Handles prepping and saving the Spock config",source:"@site/docs/reference/backend/saver.md",sourceDirName:"reference/backend",slug:"/reference/backend/saver",permalink:"/spock/reference/backend/saver",editUrl:"https://github.com/fidelity/spock/edit/master/website/docs/reference/backend/saver.md",tags:[],version:"current",frontMatter:{sidebar_label:"saver",title:"backend.saver"},sidebar:"api",previous:{title:"resolvers",permalink:"/spock/reference/backend/resolvers"},next:{title:"spaces",permalink:"/spock/reference/backend/spaces"}},c=[{value:"BaseSaver Objects",id:"basesaver-objects",children:[]},{value:"AttrSaver Objects",id:"attrsaver-objects",children:[]}],u={toc:c};function d(e){var t=e.components,n=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Handles prepping and saving the Spock config"),(0,r.kt)("h2",{id:"basesaver-objects"},"BaseSaver Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class BaseSaver(BaseHandler)\n")),(0,r.kt)("p",null,"Base class for saving configs"),(0,r.kt)("p",null,"Contains methods to build a correct output payload and then writes to file based on the file\nextension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_writers")," - maps file extension to the correct i/o handler"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_s3_config")," - optional S3Config object to handle s3 access")),(0,r.kt)("h4",{id:"__init__"},"_","_","init","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(s3_config: Optional[_T] = None)\n")),(0,r.kt)("p",null,"Init function for base class"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"s3_config")," - optional s3Config object for S3 support")),(0,r.kt)("h4",{id:"dict_payload"},"dict","_","payload"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def dict_payload(payload: Spockspace) -> Dict\n")),(0,r.kt)("p",null,"Clean up the config payload so that it can be returned as a dict representation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - dirty payload")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"save"},"save"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def save(payload: Spockspace, path: str, file_name: Optional[str] = None, create_save_path: bool = False, extra_info: bool = True, file_extension: str = ".yaml", tuner_payload: Optional[Spockspace] = None, fixed_uuid: Optional[str] = None) -> None\n')),(0,r.kt)("p",null,"Writes Spock config to file"),(0,r.kt)("p",null,"Cleans and builds an output payload and then correctly writes it to file based on the\nspecified file extension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - current config payload"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"path")," - path to save"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"file_name")," - name of file (will be appended with .spock.cfg.file_extension) -- falls back to uuid if None"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"create_save_path")," - boolean to create the path if non-existent"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extra_info")," - boolean to write extra info"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"file_extension")," - what type of file to write"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tuner_payload")," - tuner level payload (unsampled)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fixed_uuid")," - fixed uuid to allow for file overwrite")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  None"),(0,r.kt)("h4",{id:"_clean_up_values"},"_","clean","_","up","_","values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef _clean_up_values(payload: Spockspace, remove_crypto: bool = True) -> Dict\n")),(0,r.kt)("p",null,"Clean up the config payload so it can be written to file"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - dirty payload"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"remove_crypto")," - try and remove crypto values if present")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"_clean_tuner_values"},"_","clean","_","tuner","_","values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef _clean_tuner_values(payload: Spockspace) -> Dict\n")),(0,r.kt)("p",null,"Cleans up the base tuner payload that is not sampled"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - dirty payload")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"_clean_output"},"_","clean","_","output"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _clean_output(out_dict: Dict) -> Dict\n")),(0,r.kt)("p",null,"Clean up the dictionary such that it can be written to file"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out_dict")," - pre-cleaned dictionary")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"_recursive_tuple_2_list"},"_","recursive","_","tuple","_","2","_","list"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _recursive_tuple_2_list(val: Any) -> Any\n")),(0,r.kt)("p",null,"Recursively find tuples and cast them to lists"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"val")," - current value of various types")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  modified version of val"),(0,r.kt)("h2",{id:"attrsaver-objects"},"AttrSaver Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class AttrSaver(BaseSaver)\n")),(0,r.kt)("p",null,"Base class for saving configs for the attrs backend"),(0,r.kt)("p",null,"Contains methods to build a correct output payload and then writes to file based on the file\nextension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_writers")," - maps file extension to the correct i/o handler")),(0,r.kt)("h4",{id:"__init__-1"},"_","_","init","_","_"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(s3_config: Optional[_T] = None)\n")),(0,r.kt)("p",null,"Init for AttrSaver class"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"s3_config")," - s3Config object for S3 support")),(0,r.kt)("h4",{id:"_check_list_of_spock_classes"},"_","check","_","list","_","of","_","spock","_","classes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@staticmethod\ndef _check_list_of_spock_classes(val: List, key: str, all_cls: Set) -> List\n")),(0,r.kt)("p",null,"Finds lists of spock classes and handles changing them to a writeable format"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"val")," - current value that is a list"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key")," - current dictionary key in the payload"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"all_cls")," - set of all spock classes")),(0,r.kt)("h4",{id:"_recursively_handle_clean"},"_","recursively","_","handle","_","clean"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _recursively_handle_clean(payload: Spockspace, out_dict: Dict, parent_name: Optional[str] = None, all_cls: Optional[Set] = None) -> Dict\n")),(0,r.kt)("p",null,"Recursively works through spock classes and adds clean data to a dictionary"),(0,r.kt)("p",null,"Given a payload (Spockspace) work recursively through items that don","'","t have parents to catch all\nparameter definitions while correctly mapping nested class definitions to their base level class thus\nallowing the output markdown to be a valid input file"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - current payload (namespace)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out_dict")," - output dictionary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"parent_name")," - name of the parent spock class if nested"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"all_cls")," - all top level spock class definitions")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out_dict")," - modified dictionary with the cleaned data")))}d.isMDXComponent=!0}}]);