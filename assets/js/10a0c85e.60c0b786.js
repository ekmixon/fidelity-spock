"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[4054],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return k}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),u=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=u(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),d=u(n),k=l,m=d["".concat(p,".").concat(k)]||d[k]||c[k]||r;return n?a.createElement(m,i(i({ref:t},s),{},{components:n})):a.createElement(m,i({ref:t},s))}));function k(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=d;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8960:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return p},metadata:function(){return u},toc:function(){return s},default:function(){return d}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],o={sidebar_label:"saver",title:"backend.saver"},p=void 0,u={unversionedId:"reference/backend/saver",id:"reference/backend/saver",isDocsHomePage:!1,title:"backend.saver",description:"Handles prepping and saving the Spock config",source:"@site/docs/reference/backend/saver.md",sourceDirName:"reference/backend",slug:"/reference/backend/saver",permalink:"/spock/reference/backend/saver",editUrl:"https://github.com/fidelity/spock/edit/master/website/docs/reference/backend/saver.md",tags:[],version:"current",frontMatter:{sidebar_label:"saver",title:"backend.saver"},sidebar:"api",previous:{title:"payload",permalink:"/spock/reference/backend/payload"},next:{title:"spaces",permalink:"/spock/reference/backend/spaces"}},s=[{value:"BaseSaver Objects",id:"basesaver-objects",children:[]},{value:"AttrSaver Objects",id:"attrsaver-objects",children:[]}],c={toc:s};function d(e){var t=e.components,n=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Handles prepping and saving the Spock config"),(0,r.kt)("h2",{id:"basesaver-objects"},"BaseSaver Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class BaseSaver(BaseHandler)\n")),(0,r.kt)("p",null,"Base class for saving configs"),(0,r.kt)("p",null,"Contains methods to build a correct output payload and then writes to file based on the file\nextension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_writers")," - maps file extension to the correct i/o handler"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_s3_config")," - optional S3Config object to handle s3 access")),(0,r.kt)("h4",{id:"dict_payload"},"dict","_","payload"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def dict_payload(payload)\n")),(0,r.kt)("p",null,"Clean up the config payload so it can be returned as a dict representation"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - dirty payload")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"save"},"save"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def save(payload, path, file_name=None, create_save_path=False, extra_info=True, file_extension=".yaml", tuner_payload=None, fixed_uuid=None)\n')),(0,r.kt)("p",null,"Writes Spock config to file"),(0,r.kt)("p",null,"Cleans and builds an output payload and then correctly writes it to file based on the\nspecified file extension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - current config payload"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"path")," - path to save"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"file_name")," - name of file (will be appended with .spock.cfg.file_extension) -- falls back to uuid if None"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"create_save_path")," - boolean to create the path if non-existent"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extra_info")," - boolean to write extra info"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"file_extension")," - what type of file to write"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tuner_payload")," - tuner level payload (unsampled)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fixed_uuid")," - fixed uuid to allow for file overwrite")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  None"),(0,r.kt)("h4",{id:"_clean_up_values"},"_","clean","_","up","_","values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef _clean_up_values(payload)\n")),(0,r.kt)("p",null,"Clean up the config payload so it can be written to file"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - dirty payload")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"_clean_tuner_values"},"_","clean","_","tuner","_","values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef _clean_tuner_values(payload)\n")),(0,r.kt)("p",null,"Cleans up the base tuner payload that is not sampled"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - dirty payload")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"_clean_output"},"_","clean","_","output"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _clean_output(out_dict)\n")),(0,r.kt)("p",null,"Clean up the dictionary so it can be written to file"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out_dict")," - cleaned dictionary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extra_info")," - boolean to add extra info")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"clean_dict")," - cleaned output payload")),(0,r.kt)("h4",{id:"_recursive_tuple_to_list"},"_","recursive","_","tuple","_","to","_","list"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _recursive_tuple_to_list(value)\n")),(0,r.kt)("p",null,"Recursively turn tuples into lists"),(0,r.kt)("p",null,"Recursively looks through tuple(s) and convert to lists"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - value to check and set typ if necessary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typed")," - type of the generic alias to check against")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"value")," - updated value with correct type casts")),(0,r.kt)("h2",{id:"attrsaver-objects"},"AttrSaver Objects"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class AttrSaver(BaseSaver)\n")),(0,r.kt)("p",null,"Base class for saving configs for the attrs backend"),(0,r.kt)("p",null,"Contains methods to build a correct output payload and then writes to file based on the file\nextension"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Attributes"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"_writers")," - maps file extension to the correct i/o handler")),(0,r.kt)("h4",{id:"_recursively_handle_clean"},"_","recursively","_","handle","_","clean"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _recursively_handle_clean(payload, out_dict, parent_name=None, all_cls=None)\n")),(0,r.kt)("p",null,"Recursively works through spock classes and adds clean data to a dictionary"),(0,r.kt)("p",null,"Given a payload (Spockspace) work recursively through items that don","'","t have parents to catch all\nparameter definitions while correctly mapping nested class definitions to their base level class thus\nallowing the output markdown to be a valid input file"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"payload")," - current payload (namespace)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out_dict")," - output dictionary"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"parent_name")," - name of the parent spock class if nested"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"all_cls")," - all top level spock class definitions")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"out_dict")," - modified dictionary with the cleaned data")))}d.isMDXComponent=!0}}]);