"use strict";(self.webpackChunkdocs_v_2=self.webpackChunkdocs_v_2||[]).push([[9994],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=l,k=c["".concat(o,".").concat(d)]||c[d]||m[d]||r;return n?a.createElement(k,i(i({ref:t},u),{},{components:n})):a.createElement(k,i({ref:t},u))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=c;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:l,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},614:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return o},metadata:function(){return p},toc:function(){return u},default:function(){return c}});var a=n(7462),l=n(3366),r=(n(7294),n(3905)),i=["components"],s={sidebar_label:"help",title:"backend.help"},o=void 0,p={unversionedId:"reference/backend/help",id:"reference/backend/help",isDocsHomePage:!1,title:"backend.help",description:"Handles all ops for assembling and pretty printing help info",source:"@site/docs/reference/backend/help.md",sourceDirName:"reference/backend",slug:"/reference/backend/help",permalink:"/spock/reference/backend/help",editUrl:"https://github.com/fidelity/spock/edit/master/website/docs/reference/backend/help.md",tags:[],version:"current",frontMatter:{sidebar_label:"help",title:"backend.help"},sidebar:"api",previous:{title:"handler",permalink:"/spock/reference/backend/handler"},next:{title:"payload",permalink:"/spock/reference/backend/payload"}},u=[],m={toc:u};function c(e){var t=e.components,n=(0,l.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Handles all ops for assembling and pretty printing help info"),(0,r.kt)("h4",{id:"find_attribute_idx"},"find","_","attribute","_","idx"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def find_attribute_idx(newline_split_docs)\n")),(0,r.kt)("p",null,"Finds the possible split between the header and Attribute annotations"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"newline_split_docs")," - new line split text")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"idx")," - -1 if none or the idx of Attributes")),(0,r.kt)("h4",{id:"split_docs"},"split","_","docs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def split_docs(obj)\n")),(0,r.kt)("p",null,"Possibly splits head class doc string from attribute docstrings"),(0,r.kt)("p",null,"Attempts to find the first contiguous line within the Google style docstring to use as the class docstring.\nSplits the docs base on the Attributes tag if present."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"obj")," - class object to rip info from")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"class_doc")," - class docstring if present or blank str"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attr_doc")," - list of attribute doc strings")),(0,r.kt)("h4",{id:"match_attribute_docs"},"match","_","attribute","_","docs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def match_attribute_docs(attr_name, attr_docs, attr_type_str, attr_default=NOTHING)\n")),(0,r.kt)("p",null,"Matches class attributes with attribute docstrings via regex"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attr_name")," - attribute name"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attr_docs")," - list of attribute docstrings"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attr_type_str")," - str representation of the attribute type"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"attr_default")," - str representation of a possible default value")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  dictionary of packed attribute information"),(0,r.kt)("h4",{id:"handle_attributes_print"},"handle","_","attributes","_","print"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def handle_attributes_print(info_dict, max_indent: int)\n")),(0,r.kt)("p",null,"Prints attribute information in an argparser style format"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"info_dict")," - packed attribute info dictionary to print"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_indent")," - max indent for pretty print of help")),(0,r.kt)("h4",{id:"get_type_string"},"get","_","type","_","string"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_type_string(val, nested_others)\n")),(0,r.kt)("p",null,"Gets the type of the attr val as a string"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"val")," - current attr being processed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nested_others")," - list of nested others to deal with that might have module path info in the string")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"type_string")," - type of the attr as a str")),(0,r.kt)("h4",{id:"get_from_sys_modules"},"get","_","from","_","sys","_","modules"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def get_from_sys_modules(cls_name)\n")),(0,r.kt)("p",null,"Gets the class from a dot notation name"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cls_name")," - dot notation enum name")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"module")," - enum class")),(0,r.kt)("h4",{id:"handle_help_main"},"handle","_","help","_","main"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def handle_help_main(input_classes: list, module_name: str, extract_fnc: Callable, max_indent: int)\n")),(0,r.kt)("p",null,"Handles the print of the main class types"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"input_classes")," - current set of input classes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"module_name")," - module name to match"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extract_fnc")," - function that gets the nested lists within classes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_indent")," - max indent for pretty print of help")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"other_list")," - extended list of other classes/enums to process")),(0,r.kt)("h4",{id:"handle_help_enums"},"handle","_","help","_","enums"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def handle_help_enums(other_list: list, module_name: str, extract_fnc: Callable, max_indent: int)\n")),(0,r.kt)("p",null,"Handles any extra enums from non main args"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"other_list")," - extended list of other classes/enums to process"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"module_name")," - module name to match"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extract_fnc")," - function that gets the nested lists within classes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_indent")," - max indent for pretty print of help")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  None"),(0,r.kt)("h4",{id:"attrs_help"},"attrs","_","help"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def attrs_help(input_classes: Union[list, tuple], module_name: str, extract_fnc: Callable, max_indent: int)\n")),(0,r.kt)("p",null,"Handles walking through a list classes to get help info"),(0,r.kt)("p",null,"For each class this function will search ",(0,r.kt)("strong",{parentName:"p"},"doc")," and attempt to pull out help information for both the class\nitself and each attribute within the class. If it finds a repeated class in a iterable object it will\nrecursively call self to handle information"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"input_classes")," - list of attr classes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"module_name")," - name of module to match"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"extract_fnc")," - function that gets the nested lists within classes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_indent")," - max indent for pretty print of help")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  None"))}c.isMDXComponent=!0}}]);